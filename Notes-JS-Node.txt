Javascript:

Lab Setup:

1.node js
2.vs code
//////////////////////////////////////////////////////////////////////////

What is Java script?

Javascript is one of the Programming langugage.

C++/Java is Object Oriented Programming Language.

Programming paradigms

1.Procedural
2.OO
3.Functional 
4.Event driven
5.Rule based
6.Constrain oriented
etc........

Languages are reference implementation of those paradgims.

Pure and style/based PL:
...................

if any language follows one programming paradigm principle 100% which is called Pure
eg: C++ is pure object oriented Programming.

if any language mixes  many programming paradigm principle or here and there which is called 
Style /based

eg:javascript mixes many paradgims.


      "javascript is Object based , functional , event driven Programming language"

...........................................................................................

Java is pure oo?

 From java 8 , java is Object oriented, functional style programming.


/////////////////////////////////////////////////////////////////////////////////////////////

Typing: Data types:
..................

1.Strongly/static typed pl
  
  Type of variable is verified during compile time. if type mismatch, compiler throw error.
eg:
  c,c++,java.......

2.Weakly/dynamic typed pl

Type of variable is identified during run time. if type mismatch, runtime throw error.

///////////////////////////////////////////////////////////////////////////////////////

                      "javascript is dynamic typed pl"
.........................................................................................
History Of javascript:

javascript was created at "Netscap Communication" in 1995.

javascript was created for web computing :  to process HTML Pages dynamically at browser.

javascript was created by "Brendan Eich"

Time line:

1.javascript project started 1995

1.first name of the language was "Mocha"
2.language was renamed to "Live Script" -1996
3.language was renamed to "java Script" -1996

After language ready, which was submitted to standard body "ECMA international"


1996---1997 : JS 1.0 =>ES 1.0

1997- 1998 :  ES 2.0: It did not come

1999 :  ES 3

2007 : ES 4

2008 : ES 5

2012-2015 : ES 6

2016  ONWARDS : es 7,es 8, ......
...........................................................................................

Compilation,Execution, Runtime:
...............................

Javascript has no independant compiler like c++/java.

Runtime: 

 It is program, written in c / c++ , any language.
 Runtime is abstraction/communication layer between os and application programms.

Types of runtime:

1.embeded runtime
  embeded into another software
 eg:
   embeded game engines...
   browsers has lot of embbeded 

   webservers which running java code : tomcat

2.standalone runtime
  which is avaiable separatly
  JVM


Javascript runtime:
...................
 it is avaiable in both mode.

Embeded mode:
  js runtime is avaiable inside every browser.

chrome : V8 
firefox : Spider Monkey
ms : Chakara.

standalone mode:
  node js, which has standalone js runtime.
/////////////////////////////////////////////////////////////////////////////////////////////

Does javascript code is compiled?

 Yes! , inside javascript runtime, which has embbeded compiler.
////////////////////////////////////////////////////////////////////////////////////////////

We are going to use v8:
  "V8 is Googleâ€™s open source high-performance JavaScript and WebAssembly engine, written in C++. 
It is used in Chrome and in Node.js, 
////////////////////////////////////////////////////////////////////////////////////////////
Where is javascript ? what type of applications we can build using javascript?

1.javascript was created for browser only to process web documents.

Now a days  javascript is used every where.

1. javascript is in server side market : for build Webapps,webservices :Node.js
2. javascript is in mobility  : build mobile applications
3. javascript is in IOT : build any device specific applications.
/////////////////////////////////////////////////////////////////////////////////////////////

Java Script Programming language: ES 5 AND ES 6
...............................................

1.language fundamentals
2.functional programming
3.Object based programming
4.Browser specific features
   DOM,AJAX.

Node Js:
   Build Nonblocking IO applications 

/////////////////////////////////////////////////////////////////////////////////////////

1.language fundamentals

types,variables, values : literals

JS dynamic typed language : no type system.

Declare variable

 var | let | const | this  variableName = value(literals).

literals : values based on it only the type of variable is identified during runtime.

literals types:

1.string
2.number
3.boolean
4.undefined
5.NaN
6.infinity
7.function
8.null
9.object

 var : is used in es 5
 let and const is used in es 6
 this : both version


Note: 
1.var,let,const all are same only but there are few differences, to be disucssed latter.
 var vs let and const.

2.In js ; is optional 


Point:

  if you are building javascript application based on es 6, recommandation is use "let and
const" always.


1.strings:

1.16 bit unicode charaters.

2.strings can be declared inside  "" or ''  or ``(back-tick) es 6 feature
   "" : inspired from java and c++
   '' : js specific notation.
  
3.string concatnation can be done
   +  and , and `foo ${variableName}`



/**
 * strings
 */

//es 5 syntax only for few examples 

var firstName = "Subramanian";
var lastName = 'Murugan'
//print
console.log("Full Name " + firstName + lastName);
console.log("Full Name", firstName, lastName);
//es6 string 
console.log(`Full Name ${firstName} ${lastName}`)
let city = 'Coimbatore';
//back tick notation use case : for string concatation : template literal
console.log(`City ${city}`)
//back tick notation use case : for multi line string literal
//es 5 multi line strings
let title = 'Sony'
let htmlDoc = "<html>" +
    "<head><title>" +
    title +
    "</title>" +
    "</head>" +
    "<body><h1>Sony Digital</h1>" +
    "</body></html>";

console.log(htmlDoc);
//es 6 multi line strings
let htmlnewDoc = `<html>
    <head>
    <title>${title}</title>
    </head>
    <body><h1>Sony Digital</h1>
    </body></html>`;
console.log(htmlnewDoc);
/////////////////////////////////////////////////////////////////////////////////////////
Numbers:

1.number size is 64 bit by default aka double.
2.It is IEEE 754 Standard.


//numbers
//numbers
let price = 10;
let qty = 100;
//numerical compuation
let totalPrice  =  price * qty;
let avgPrice = totalPrice / 2;

console.log(`Price is ${price} and qty is ${qty}`);
console.log(`Total Price ${totalPrice}`)
console.log(`Avg Price ${avgPrice}`)

operators: numerical operations
Note : all operators from c/c++/java is available in javascript
 

undefined:
..........
It is value, assigned to a variable, if no valid literal is assigned.

let firstName;
let price;
let qty;
console.log(`First Name ${firstName}`);
console.log(`price ${price} ${qty}`);

///////////////////////////////////////////////////////////////////////////////////////

Related to Numbers:

1.NaN :Not a Number 

Not a Number but is number.
NaN is error code.
NaN error code will come due to numerical compuation failures.

Note:

 if you get NaN as out put, it is danger/toxic , it is runtime error, you need to fix.

When NaN will come?
 
//NaN use case 1; if you do numerical compuation against undefined

let price =100; //number
let qty; // undefined
let totalPrice  = price * qty; // number * undefined
console.log(`total price ${totalPrice}`);

Type conversion : string to number

types of Type conversion

1.implicit Type conversion
 js automatically converts string to number
2.explicit Type conversion
 js uses conversion utility apis to convert string to number.



//NaN use case 1; if you do numerical compuation against undefined

let price = 100; //number
let qty; // undefined
let totalPrice = price * qty; // number * undefined
console.log(`total price ${totalPrice}`);

//Type conversion : implicit
let x = "10";//type is string but value is number
let y = 10;
let totalValue = x * y; // x value is converted into number first and then computation starts
console.log(`Total Value ${totalValue}`)

//Type convserion : explicity Using parse Utilty
let a = "10";
let b = 90;
let totalA = parseFloat(a) + b;
console.log(`Parse Functions ${totalA}`);

//Use case 2:NaN during type conversion
let stockValue = "$10"; 
//let totalStock = stockValue * 10; // stockvalue is converted from string to number but special character will cause nan
let totalStock = parseInt(stockValue) * 10;
console.log(`Type conversion Error ${totalStock}`);


2.infinity
div by 0

let price = 1000;
let avgPrice = price / 0;
console.log(`Avg Price ${avgPrice}`);
/////////////////////////////////////////////////////////////////////////////////////////
booleans:
  
js supports booleans with value of true / false


constrol structures

1. if ... if ..else, switch case : similar to c / c ++ and java

operators 
 Tenary operator : to replace if condtion.

Equality operator:

==, ===
!=,!==

== : compares only value and does not compare type.
     it is bug. buggy operator.
=== : Compares value and type

Recommandation : Use always "==="


comparsional operators

 <,<=,>,>=, : similar to c and c++

conditional operators

 || ,&& 


In js which is true and which falsy:
////////////////////////////////////

In js every thing is true expect the following values.

Falsy Values:

1.boolean false
2.0
3.undefined
4.empty string "",''
5.NaN
6.null

//booleans

let isActive = true;
let isEnabled = false;
console.log(`IsActive ${isActive}`);
console.log(`Is Enabled ${isEnabled}`);

if (isActive) {
    console.log('Active')
} else {
    console.log('In active');
}
//tenary operator
isEnabled ? console.log('Enabled') : console.log('Disabled')

//Eq: if you are comparing two variables

let a = 10;
let b = 10;
if (a == b) {
    console.log('A and B are equal')
} else {
    console.log('A and B are not equal')

}

//comparing strings and numbers not valid

let x = "10";
let y = 10;
if (x == y) {
    console.log('X and Y are equal')
} else {
    console.log('X and Y are not equal')
}
if (x === y) {
    console.log('X and Y are equal')
} else {
    console.log('X and Y are not equal')
}
//||
if (isActive || isEnabled) {
    console.log('Ok')
} else {
    console.log('Not Ok!')
}
//////////////////////////////////////////////////////////////////////////////////
//Advanced booleans

let start = 1;
if (start) {
    console.log('Started')
} else {
    console.log('Not Started')
}

let message;
let res = message ? "Hai" : "Welcome"
console.log(res);
/////////////////////////////////////////////////////////////////////////////////
// || 

/**
 * if first operand(price) is truthy , the result would be first operand else 
 * result would be second
 */
let price = 199;
let priceValue = price || 10;
console.log(`Price Value ${priceValue}`);

// && : please follow the above rule but opposit
........................................................................................


Type of variable, reinitalization:
...................................

js provides a special operator called "type of" operator

type of operator
1.returns the runtime type of value in smaller case "number"


//how to reinitalize the variables.

let myvariable = 100;
let price;
let name = "test"
let a = 10;
let b = "$90";
let ab = a * b;
let x = 10 / 0;

console.log(typeof myvariable)
console.log(typeof price)
console.log(typeof name);
console.log(typeof ab);
console.log(typeof x);

//////////////////////////////////////////////////////////////////////////
let foo = 10;
console.log(typeof foo);
foo = true;
console.log(typeof foo);
foo ="test";
console.log(typeof foo);
////////////////////////////////////////////////////////////////////////////////

//what if i dont want to reinitalize the variable
const PI =3.14
console.log(`PI ${PI}`);
//PI =90.89;
//console.log(`PI ${PI}`);

//const variable must have been initalized to any value
// const FOO;
// console.log(`FOO ${FOO}`);

//////////////////////////////////////////////////////////////////////////////////

//loops
for (let i = 0; i < 10; i++) {
    console.log(i);
}
//while , do while remains same other languages

other keywords:
break,continue,switch...
/////////////////////////////////////////////////////////////////////////////////////////////

Functions and functional programming:
....................................

in javascript logic is represented in functions.


syntax:

 function functionName(Args){
   //body
   return statement
 }


//functions declaration

function sayHello() {
    console.log('Hello!')
}
//function calling/ invocation
sayHello();
////////////////////////////////////////////////////////////////////////
//Args and Parameters

//a and b are args
//default values : default args
function add(a = 1, b = 1) {
    let result = a + b;
    console.log(`Add Result is ${result}`);
}
//10,10 are parameters
add(10, 10);
//parameters are hardcoded
add(1, 1);
//parameters are passed through variables
let x = 90;
let y = 90;
add(x, y);

//if no parameters are passed
add(); //undefined,undefined

add(12); //value,undefined
/////////////////////////////////////////////////////////////////////////////////

//i want to design function which should take no of parameters,but i dont know 
//in advance
//es 6 : var args : using rest operator
function logger(context, ...args) {
    //in es5 , argugments
    //console.log(arguments)
    console.log(context, args);
}
logger('Application', 'info', 'This is good message');
logger('Device', 'error', 'Something went wrong', 501);
////////////////////////////////////////////////////////////////////////////////
//return statement
function getStockValue() {
    return 100;
}
console.log(getStockValue());
function getQty() {
    let qty = 100;
    return qty;
}
console.log(getQty());
function getInfo(info) {
    return info;
}
console.log(getInfo('this is javascript!'));

function login(userName, password) {
    if (userName === 'admin' && password === 'admin') {
        return true;
    }
    return; //undefined : falsy value
}
login('admin', 'admin') ? console.log('Login success!') : console.log('Login failed!');
login('foo', 'foo') ? console.log('Login success!') : console.log('Login failed!');

/////////////////////////////////////////////////////////////////////////////////////

function literals:
.................

function is value /literal like numbers

let a =10;

function can be assigned to a variable.

once if you assign function to a variable, that variable is used to point that function
and that variable can be used to invoke that function.


/**
 * 
once if you assign function to a variable, that variable is used to point that function
and that variable can be used to invoke that function.
**/

//way -1
function sayHello(name) {
    console.log('hello', name)
    return `Hello ${name}`;
}
let hello = sayHello;
//invoke that function
let result = hello('Subramanian');
console.log(result);
//////////////////////////////////////////////////////////////////////////////////

//anonmous function : function without name
let hai = function (name='defaultName') {
   //console.log(`Hai ${name}`)
   return `Hai ${name}`;
};
console.log(hai('subramanian'));
///////////////////////////////////////////////////////////////////////////////////

function parameters:

What could be function parameters?

 "Any literal" : number,string,boolean,undefined,"function",objects

//function as parameter to another function

//connect =function(){}
function startServer(connect) {
    const result = connect('HTTP');
    console.log(result);
}

startServer(function (name) {
    // console.log(`${name} Server Started!`);
    return `${name} Server Started!`
});
///////////////////////////////////////////////////////////////////

function startClient(connect) {
    connect('Mobile');
}
let handler = function (name) {
    console.log(`${name} Client is ready!`);
};
startClient(handler);

/////////////////////////////////////////////////////////////////////////////////

Returning function from another function:
..........................................

Since function is literal, we can return function from another function.


function welcome() {
    console.log('welcome')
    //nested function
    function sayHello(name) {
        console.log('Hello!!!!', name);
    }
    //sayHello();
    return sayHello;
}
let hello = welcome();
hello('Subramanian');
//////////////////////////////////////////////////////////////////////////
function counter() {
    return function () {
        return 10;
    }
}
let inc = counter()
console.log(inc());

//short cut
console.log(counter()());
///////////////////////////////////////////////////////////////////////////////////
//Deep nesting: function inside funciton inside function
//CURRRY Function
function prepareCake(iceCream) {
    return function (sugar) {
        return function (milk) {
            return function (color) {
                return `${iceCream} ${sugar} ${milk} ${color} `
            }
        }
    }
}
let cake = prepareCake('cream')('sugar')('milk')('color')
console.log(`Cake : ${cake}`);

///////////////////////////////////////////////////////////////////////////////////////////

ES 6 Function declaration:

 Arrow functions:
////////////////////

Why arrow functions

1.simple syntax : syntax sugar on function declaration

2.the value of "this" is different 


//es 5 function declaration
let hai = function () {
    console.log('Hai');
};
hai();
//arrow functions

let hi = () => {
    console.log('Hai');
};
hi();
//arrow function flavours

//1.if function has only one line of body; remove {}
hi = () => console.log('Hai');
hi();
/////////////////////////////////////////////////////////////////////////////////
//2.args and parameters: multi parameters with default value
let add = (a = 0, b = 0) => {
    let r = a + b;
    console.log(`The result is ${r}`);
};
add(1, 1);
/////////////////////////////////////////////////////////////////////////////////
//3.Single parameter, no default value : drop ()
let setName = name => console.log(`Name ${name}`);
setName('Subramamanian')
////////////////////////////////////////////////////////////////////////////////
//4.No Parameter drop () / _
let greet = _ => console.log('Greetings!');
greet();
///////////////////////////////////////////////////////////////////////////////
//5.Return value
let substract = (a = 0, b = 0) => {
    return a - b;
};
console.log(substract(2, 1));
//6.only return : you can drop {} and return statement
substract = (a = 0, b = 0) => a - b;
console.log(substract(2, 1));
//////////////////////////////////////////////////////////////////////////////////
//7.single parameter ,no default value , return the same.
let stock = value => value;
console.log(stock(2000));
//////////////////////////////////////////////////////////////////////////////////
//how to pass function as parameter in arrow version.
// function startServer(connect) {
//     connect('HTTP');
// }
let startServer = connect => connect('HTTP');
// startServer(function () {
//     console.log(`Server Started!`);
// });
startServer(name => console.log(` ${name} Server Started!`));
//////////////////////////////////////////////////////////////////////////

// function startClient(connect) {
//     connect('Mobile');
// }
let startClient = connect => connect('Mobile');

let handler = name => console.log(`${name} Client is ready!`);
startClient(handler);
///////////////////////////////////////////////////////////////////////////////
//return arrow 
// function counter() {
//     return function () {
//         return 10;
//     }
// }
// const counter = () => {
//     return () => 10;
// }
const counter = () => () => 10;
let inc = counter()
console.log(inc());
console.log(counter()());
/////////////////////////////////////////////////////////////////////////////////

// function prepareCake(iceCream) {
//     return function (sugar) {
//         return function (milk) {
//             return function (color) {
//                 return `${iceCream} ${sugar} ${milk} ${color} `
//             }
//         }
//     }
// }
const prepareCake = iceCream => sugar => milk => color => `${iceCream} ${sugar} ${milk} ${color} `
let cake = prepareCake('cream')('sugar')('milk')('color')
console.log(`Cake : ${cake}`);
//////////////////////////////////////////////////////////////////////////////////////////
Immediately-invoked Function Expression :
........................................

(function () {
    statements
})();

//iife

let result = (function (game) {
    console.log(`${game} is initalized`);
    return 'Version 1.0.0'
})('Game');
console.log(result);

let res = (game => {
    console.log(`${game} is initalized`);
    return 'Version 1.0.0'
})('Play Station');
/////////////////////////////////////////////////////////////////////////////////////////////

Object based Programming:
.........................

Object based vs Object oriented Concept:
........................................

OO concepts:
...........

1.Abstraction
   class based
2.Encapsulation
   code sharing visibility
3.Modularity
   -code sharing
4.Hierachy
   -HAS-A 
   -IS-A inheritance
5.Typing
   -Polymorphsim
      -Compile - runtime
----------------------
6.Concurrency
   -Process level Multi threading
   -Kernal level multi threading : Async
7.Persistency
  -stroage


if any language does not support any one of  first 5 principles fully or paritally then
those languages are called as Object based language.

//////////////////////////////////////////////////////////////////////////////////////////

What is Object?

Object can be explained in three views

1.real time
   Any thing can be object, but it should be in problem domain.
2.software modeling
   UML digarams
3.Program view
   Memory representation.

In languages:

 Objects are runtime representation of data and methods which are grouped under one single
 unit we "class".

Javascript is class free object based pl. no classes like traditional oo language.

classes are repsented in js as functions.

Roles of Functions

1.function can act as stack frame. holding biz logic
2.function can act as Object template(class)

How decision is made about function 

  - during function invocation.

funciton invocation syntax

    fun();  => stack frame creation.
 new fun(); => Object creation

/////////////////////////////////////////////////////////////////////////////////////

Coding standards:
................

1.functions

 if function is declared for holding biz logic, then

  name of the function should be 

         verb  => start,stop,calculate.....
         verb+Noun => startServer, stopServer...

 if function is declared for creating objects then

  name of the function should be 
       Noun =>Employee,Customer,Player,PlayStation,Patient
////////////////////////////////////////////////////////////////////////////////////

            Objects are created inside javascript runtime "Heap Memory".

Objects Creational Patterns:

1.Constructor pattern
   functions
   classes : es 6
   
2.Literal Pattern

Object => state + Behaviour =>instance variables and instance methods
 how to declare object properties(state,behaviour)
  "this" : keyword  is used to declare



//declare class , object properties

function Employee() {
    //state
    this.id = 1;
    this.name = 'Subramanian';
    this.city = 'Coimbatore';
    this.salary = 12000;
    this.da = 1000;
    this.hra = 2000;
    //behaviours : methods
    this.calculateSalary = function () {
        return this.salary + this.hra + this.da;
    }
    this.calculateTax = function () {
        return (this.salary + this.hra + this.da) * 10 / 100
    }
}
//object creation
//emp is reference variable
//new is operator
//Employee() ;; function call , constructor call
const emp = new Employee();
//Access Object Properties : using .operator / [] operator.
console.log(`Id ${emp.id} Name ${emp.name} city ${emp.city}`)
console.log(`Salary ${emp.calculateSalary()}`);
console.log(`TAX ${emp.calculateTax()}`);
///////////////////////////////////////////////////////////////////////////////////////////

state initalizations:

1.hardcoded state
this.id = 1;
    this.name = 'Subramanian';
    this.city = 'Coimbatore';
    this.salary = 12000;
    this.da = 1000;
    this.hra = 2000;
  

2.after object creation
 by using reference variable you can update object properties


//state initalization

function Employee() {
    //hardcoded
    this.id = 1;
    this.name = 'Subramanian';
    this.city = 'Coimbatore';
    this.salary = 12000;
    this.da = 1000;
    this.hra = 2000;
    //behaviours : methods
    this.calculateSalary = function () {
        return this.salary + this.hra + this.da;
    }
    this.calculateTax = function () {
        return (this.salary + this.hra + this.da) * 10 / 100
    }
}
//object creation
//emp is reference variable
//new is operator
//Employee() ;; function call , constructor call
const emp = new Employee();
//Access Object Properties : using .operator / [] operator.
console.log(`Id ${emp.id} Name ${emp.name} city ${emp.city}`)
console.log(`Salary ${emp.calculateSalary()}`);
console.log(`TAX ${emp.calculateTax()}`);

//new values
emp.id =1999;
emp.name = 'Ram';
emp.city = 'Banaglore';
emp.salary =7888;
emp.da=300;
console.log(`Id ${emp.id} Name ${emp.name} city ${emp.city}`)
console.log(`Salary ${emp.calculateSalary()}`);
console.log(`TAX ${emp.calculateTax()}`);


/////////////////////////////////////////////////////////////////////////////////////////

3.using constructor parameters

//How many objects you can create using single function
//You can create More objects.


//default constructor args
function Employee(id = 1, name = 'Subramanian', city = 'Coimbatore', salary = 1000, da = 1000, hra = 2000) {
    this.id = id;
    this.name = name;
    this.city = city;
    this.salary = salary
    this.da = da;
    this.hra = hra;
    //behaviours : methods
    this.calculateSalary = function () {
        return this.salary + this.hra + this.da;
    }
    this.calculateTax = function () {
        return (this.salary + this.hra + this.da) * 10 / 100
    }
}
let emp = null;

console.log(emp);

emp = new Employee();
console.log(`Id ${emp.id} Name ${emp.name} city ${emp.city}`)
console.log(`Salary ${emp.calculateSalary()}`);
console.log(`TAX ${emp.calculateTax()}`);

emp = new Employee(3, 'karthik', 'chennai', 7888, 800, 1200);
console.log(`Id ${emp.id} Name ${emp.name} city ${emp.city}`)
console.log(`Salary ${emp.calculateSalary()}`);
console.log(`TAX ${emp.calculateTax()}`);


emp = new Employee(4, 'John', 'chennai', 7888, 800, 1200);
console.log(`Id ${emp.id} Name ${emp.name} city ${emp.city}`)
console.log(`Salary ${emp.calculateSalary()}`);
console.log(`TAX ${emp.calculateTax()}`);

//this for garbage collection
emp = null;
//////////////////////////////////////////////////////////////////////////////////////////

Some of the errors when you access object properties:
....................................................
let emp;
console.log(emp);
console.log(`Id ${emp.id} Name ${emp.name} city ${emp.city}`)




console.log(`Id ${emp.id} Name ${emp.name} city ${emp.city}`)
                      ^

TypeError: Cannot read property 'id' of undefined
    at Object.<anonymous> (C:\session\sony\js-apps\src\index.js:19:23)
    at Module._compile (internal/modules/cjs/loader.js:959:30)
    at Object.Module._extensions..js (internal/modules/cjs/loader.js:995:10)
    at Module.load (internal/modules/cjs/loader.js:815:32)
    at Function.Module._load (internal/modules/cjs/loader.js:727:14)
    at Function.Module.runMain (internal/modules/cjs/loader.js:1047:10)
    at internal/main/run_main_module.js:17:11



let emp=null;
console.log(emp);
console.log(`Id ${emp.id} Name ${emp.name} city ${emp.city}`)


console.log(`Id ${emp.id} Name ${emp.name} city ${emp.city}`)
                      ^

TypeError: Cannot read property 'id' of null
    at Object.<anonymous> (C:\session\sony\js-apps\src\index.js:19:23)
    at Module._compile (internal/modules/cjs/loader.js:959:30)
    at Object.Module._extensions..js (internal/modules/cjs/loader.js:995:10)
    at Module.load (internal/modules/cjs/loader.js:815:32)
    at Function.Module._load (internal/modules/cjs/loader.js:727:14)
    at Function.Module.runMain (internal/modules/cjs/loader.js:1047:10)
    at internal/main/run_main_module.js:17:11
///////////////////////////////////////////////////////////////////////////////////////////

Hierachy :

 Object Relation ship.

HAS-A :composition 

function Address(doorno = '1', street = 'street', city = 'city', state = 'state', zipcode = 'zipcode') {
    this.street = street
    this.doorno = doorno
    this.city = city;
    this.state = state;
    this.zipcode = zipcode
}

function Employee(id = 1, name = 'defaultName', address = new Address()) {
    this.id = id;
    this.name = name;
    //has-a 
    this.address = address;
}
let emp = null;

emp = new Employee();
console.log(`Id ${emp.id} Name ${emp.name} ${emp.address.city}`)

let address = new Address('23', '10 th street', 'chennai', 'TN', '600002')
emp = new Employee(34, 'John', address);
console.log(`Id ${emp.id} Name ${emp.name} ${emp.address.city}`)

emp = new Employee(34, 'John', new Address('23', '10 th street', 'chennai', 'TN', '600002'));
console.log(`Id ${emp.id} Name ${emp.name} ${emp.address.city}`)
///////////////////////////////////////////////////////////////////////////////////////////

IS-A : inheritance 

Javascript is object based language.

JS inherits Objects from Objects not classes.
  -Object inheritance

JS A prototype-based language?

   What is ProtoType?
      It is Object , used for inheritance, sharing properties across multiple instances
/////////////////////////////////////////////////////////////////////////////////////////////

Program :  Collection of instructions.
instructions : collections of data , methods.

Types of program
1.passive
   The program which is not in RAM
   The program which is in RAM but which is not accessed by CPU 
2.active

 The program which is in RAM
 The program which is in RAM but which is  accessed by CPU 
 
Active Programs called as process.

Every Process /any thing in RAM has common structure:
///////////////////////////////////////////////////////////////////////////////////////////

Objects :

 passive : which is in heap ,but not accessing.
 active : accessd by cpu

////////////////////////////////////////////////////////////////////////////////////////////

Object and Proto type:

 In javascript everything is Object including function.

every function in javascript is Object, we call "Function"

function Employee(){

}

console.log(Employee.name)

 Employee()====>Employee.call()===>stack

 new Emplyee()=====> Heap


 instance : active  heap epresentation of "function object"  

Prototype is "passive Represention" 

Points:

1.Every instance is created from "Passive" function Object

   "Object itself act as instance template"
   "In java Class Object is used to create real instances"

 function(meta)---->new Instance()

2.Any instance is created from functions will have its own prototype Passive Object.



//////////////////////////////////////////////////////////////////////////////////////////

function Employee(id = 1) {
    //instance variable
    this.id = id;
}

//Getting Employee's Prototype
console.dir(Employee.prototype);

//Add sharable properties on prototype ,so that all instance can get the data
Employee.prototype.firstName = 'foo'
Employee.prototype.calculateSalary = function () {
    return 1000;
}

let emp = null;

emp = new Employee() //new Instance from Employee Function Object
emp.id = 9000;
//overriding
emp.calculateSalary = function () {
    return 67800;
}


console.log(emp.id, emp.firstName, emp.calculateSalary())

emp = new Employee() //new Instance from Employee Function Object
console.log(emp.id, emp.firstName, emp.calculateSalary())

emp = new Employee() //new Instance from Employee Function Object
console.log(emp.id, emp.firstName, emp.calculateSalary())

///////////////////////////////////////////////////////////////////////////////////////

Object Augmentation , Object property lookup,Prototype chain:
.............................................................

Object Augmentation:


Object ==Memory Representation.
  What is internal structure of object in c++ /java
  instance data + vtable.

Javascript objects are dictionary /hash table/ hash map
   all javascript objects simple key--value pair datastructure.

class A{
 int x; 

 getX
}

A ===> x +vtable(getx)===>Object 

once object is created , its structure cant be altered
 like adding new property,delete existing proprety while running.

But in js it is possible, you can add,update,delete,iterate: how
  because it is simple datastructure.
  "This is process we can object augmentation".


//Object Augmentation: Adding,deleting,updating,iterating object.

function Employee() {
    //no property
}
//Proto type augmentation
Employee.prototype.salary = 9000;
let emp = new Employee();

console.dir(emp);

//Add new property
emp.id = 1000;
emp.name = 'Ram' //add operation
console.log(`Id ${emp.id} Name ${emp.name}`)
//if prop found, then update else add.
emp.name = 'suburamanian' //update operation
emp.city = 'coimbatore'

//when you look up property, first js search the property in the current
//object---if not-->it looks up its immedate parent(Prototype)--if not--it 
//looks up its immedate parent---Object
console.log(`Id ${emp.id} Name ${emp.name} ${emp.city} ${emp.salary}`) //getters

//delete a property
delete emp.city;
console.log(`Id ${emp.id} Name ${emp.name} ${emp.city} ${emp.salary}`) //getters


//iterations

//object for.in.loop

for (key in emp) {
    console.log(key, emp[key]); // [] dymamic prop value access:
}
///////////////////////////////////////////////////////////////////////////////////////////

ES 6 classes 

//

class Employee {
    //instance variables
    id = 1;
    name = 'Subramanian'
    //methods
    calculateSalary() {
        return 1000;
    }
    calculateTAX = () => 3000;
}
let emp = new Employee();
console.log(`Id ${emp.id}  salary ${emp.calculateSalary()} ${emp.calculateTAX()}` );
///////////////////////////////////////////////////////////////////////////////////////////

//state intialization in classes

//

class Employee {
    //instance variables
    constructor(id = 1, name = 'defaultName') {
        this.id = id;
        this.name = name;
    }
    //methods
    calculateSalary() {
        return 1000;
    }
    calculateTAX = () => 3000;
}
let emp = null;
emp = new Employee();
console.log(`Id ${emp.id} ${emp.name}  salary ${emp.calculateSalary()} ${emp.calculateTAX()}`);
//after object creation
emp = new Employee();
emp.id = 90000;
emp.name = 'john'
console.log(`Id ${emp.id} ${emp.name}  salary ${emp.calculateSalary()} ${emp.calculateTAX()}`);

//constructor params
emp = new Employee(45, 'Kumar');
console.log(`Id ${emp.id} ${emp.name}  salary ${emp.calculateSalary()} ${emp.calculateTAX()}`);
///////////////////////////////////////////////////////////////////////////////////////////

class Address {
    constructor(doorno = '1', street = 'street', city = 'city', state = 'state', zipcode = 'zipcode') {
        this.street = street
        this.doorno = doorno
        this.city = city;
        this.state = state;
        this.zipcode = zipcode
    }
}

class Employee {
    constructor(id = 1, name = 'defaultName', address = new Address()) {
        this.id = id;
        this.name = name;
        //has-a 
        this.address = address;
    }
}
let emp = null;

emp = new Employee();
console.log(`Id ${emp.id} Name ${emp.name} ${emp.address.city}`)

let address = new Address('23', '10 th street', 'chennai', 'TN', '600002')
emp = new Employee(34, 'John', address);
console.log(`Id ${emp.id} Name ${emp.name} ${emp.address.city}`)

emp = new Employee(34, 'John', new Address('23', '10 th street', 'chennai', 'TN', '600002'));
console.log(`Id ${emp.id} Name ${emp.name} ${emp.address.city}`)
/////////////////////////////////////////////////////////////////////////////////////////////

class and inheritance:
......................

class Account {
    constructor(firstName = 'firstName') {
        this.firstName = firstName;
        console.log('Account is initalized')
    }
    //methods
    withdraw() {
        return 100;
    }
}
Account.prototype.secKey = 'XXX@#$#$'
Account.prototype.deposit = function(){
    return 0;
}

class SavingsAccount extends Account {
    constructor(firstName) {
        super(firstName);//call super class constructor
        console.log('SavingsAccount is initalized')
    }
    //redefining
    withdraw() {
        return 100888 * super.withdraw();
    }
}
let sb = new SavingsAccount('Subramanian');
console.log(`${sb.firstName} withdraw ${sb.withdraw()} ${sb.deposit()} ${sb.secKey}`)


////////////////////////////////////////////////////////////////////////////////////////////

Literal Objects:

1.no function/classes to create object

let refVar = {
 key:literal,
 key:literal
}


//literal objects

let emp = {
    id: 1,
    name: 'Subramanian',
    salary: 1900,
    isActive: true,
    //methods
    //es 5
    // calculateSalary: function () {
    //     return 1000;
    // }
    //es 6
    //calculateSalary: () => 1000
    //es 6 class like methods
    calculateSalary(){
        return 1000
    }

};
console.log('Employee information')
console.log(`Id ${emp.id} name ${emp.name} salary ${emp.salary}`)
console.log(`Total Salary ${emp.calculateSalary()}`)
///////////////////////////////////////////////////////////////////////////////

state intialization:
//literal objects :state initalization 
//hardcoded

let emp = {
    id: 1,
    name: 'Subramanian',
    salary: 1900,
    isActive: true,
    calculateSalary() {
        return 1000
    }

};
console.log('Employee information')
console.log(`Id ${emp.id} name ${emp.name} salary ${emp.salary}`)

emp.id = 9000
emp.name = 'ram'
console.log(`Id ${emp.id} name ${emp.name} salary ${emp.salary}`)

console.log(`Total Salary ${emp.calculateSalary()}`)
/////////////////////////////////////////////////////////////////////////////////////////

HAS-A and is-a :


//has-a relationship

let emp = {
    id: 1,
    name: 'Subramanian',
    salary: 1900,
    isActive: true,
    //has-a
    address: {
        city: 'Chennai',
        state: 'TN'
    },
    calculateSalary() {
        return 1000
    }

};
console.log('Employee information')
console.log(`Id ${emp.id} name ${emp.name} salary ${emp.salary} ${emp.address.city}`)

/////////////////////////////////////////////////////////////////////////////////////////////

Literal Object keys and values:

Literal object key has its data type and value type is differnt

 id:10
 id has one datatype
 10 is one datatype

Point :

 key data type is always string.
 
 string means must be enclosed with "" or '' ``.


let emp = {
    id: 1,
    name: 'Subramanian',
    salary: 1900,
    isActive: true,
    //has-a
    address: {
        city: 'Chennai',
        state: 'TN'
    },
    calculateSalary() {
        return 1000
    }

};

look at above code keys not enclosed as string literal
   but if not also it is string.

can i add double quotes to key : yes



//has-a relationship

let emp = {
    "id": 1,
    "name": 'Subramanian',
    "salary": 1900,
    "isActive": true,
    //has-a
    "address": {
        "city": 'Chennai',
        "state": 'TN'
    },
    calculateSalary() {
        return 1000
    }

};
console.log('Employee information')
console.log(`Id ${emp.id} name ${emp.name} salary ${emp.salary} ${emp.address.city}`)
////////////////////////////////////////////////////////////////////////////////////////////
Object Destructuring: ES 6
..........................

Destructuring means breaking the object into keys.




//passing object as parameter

// function printEmployee(emp) {
//     console.log(`Id ${emp.id}`)
//     console.log(`Name ${emp.name}`)
//     console.log(`Salary ${emp.salary}`)
//     console.log(`IsActive ${emp.isActive}`)
//     console.log(`City ${emp.address.city}`)
//     console.log(`State ${emp.address.state}`)
// }


// function printEmployee(emp) {
//     //Object destrucing
//     const { id, name, salary, calculateSalary, 
//         isActive, address: { city, state } } = emp;
//     console.log(`Id ${id}`)
//     console.log(`Name ${name}`)
//     console.log(`Salary ${salary} ${calculateSalary()}`)
//     console.log(`IsActive ${isActive}`)
//     console.log(`City ${city}`)
//     console.log(`State ${state}`)
// }

// function printEmployee({ id, name, salary, calculateSalary,
//     isActive, address: { city, state } }) {
//     console.log(`Id ${id}`)
//     console.log(`Name ${name}`)
//     console.log(`Salary ${salary} ${calculateSalary()}`)
//     console.log(`IsActive ${isActive}`)
//     console.log(`City ${city}`)
//     console.log(`State ${state}`)
// }
const printEmployee = ({ id, name, salary, calculateSalary,
    isActive, address: { city, state } }) => {
    console.log(`Id ${id}`)
    console.log(`Name ${name}`)
    console.log(`Salary ${salary} ${calculateSalary()}`)
    console.log(`IsActive ${isActive}`)
    console.log(`City ${city}`)
    console.log(`State ${state}`)
}


let emp = {
    id: 1,
    name: 'Subramanian',
    salary: 1900,
    isActive: true,
    //has-a
    address: {
        city: 'Chennai',
        state: 'TN'
    },
    calculateSalary() {
        return 1000
    }

};
printEmployee(emp);

////////////////////////////////////////////////////////////////////////////////////////

//Object returning and destrucing


// function getEmployee(id = 1, name = 'Subramanian', isActive = false, salary = 1900, city = 'Chennai', state = 'TN') {
//     return {
//         id: id,
//         name: name,
//         salary: salary,
//         isActive: isActive,
//         //has-a
//         address: {
//             city: city,
//             state: state
//         }
//     };
// }

// function getEmployee(id = 1, name = 'Subramanian', isActive = false, salary = 1900, city = 'Chennai', state = 'TN') {

//     //If key:localvariable is same eg id:id - Make it one, remove any one
//     return {
//         id,
//         name,
//         salary,
//         isActive,
//         //has-a
//         address: {
//             city,
//             state
//         }
//     };
// }
//Arrow version
const getEmployee = (id = 1, name = 'Subramanian',
    isActive = false, salary = 1900, city = 'Chennai', state = 'TN') => ({
        id,
        name,
        salary,
        isActive,
        address: {
            city,
            state
        }
    });


const { id, name, salary, calculateSalary,
    isActive, address: { city, state } } = getEmployee();
console.log(`Id ${id}`)
console.log(`Name ${name}`)
console.log(`Salary ${salary} `)
console.log(`IsActive ${isActive}`)
console.log(`City ${city}`)
console.log(`State ${state}`)
////////////////////////////////////////////////////////////////////////////////////////////

Javascript Built in Objects:
...........................

1.Object

 Object super class /Object in js.
 Every object has Object super object.
//Buit in objects

//Object

const emp = {
    id: 1
}
Object.freeze(emp);
//add new Property
emp.name = 'subramanian'

console.log(emp.id, emp.name)

//Object.assign  : clone the Object  , return new object

const customer = {
    id: 1
}
const newCustomer = Object.assign({}, customer, { name: 'Subramanian', city: 'coimbatore' })
console.log(newCustomer)

2.Wrapper Objects 
   Any wrapper objects 
     - new WrapperFunction() = new Number(), new String(), new Boolean()
     - literal pattern "" ,10,true =>This is recommended.

    "es" =>instance String Object
 
//wrappers :

let name = "hello".trim().toUpperCase();//create string object
console.log(name)

//Numbers
let stockValue =89.837342.toFixed(2)
console.log(stockValue)

3.Array : Datastructure

Array is Object
Array is dynamic 
Array can act as queue,stack.....

//Array Objects

//how to declare basic prmitive arrays
let numbers = [1, 2, 3, 4, 5, 6, 7, 8];
//Iterate :
//for..loop : dont use
for (let i = 0; i < numbers.length; i++) {
    console.log(numbers[i]);
}
//iterators: for..each
numbers.forEach((i, index) => console.log(i));
///////////////////////////////////////////////////////////////////////////////
//List of employees
const employees = [
    { id: 1, name: 'A1', salary: 100 },
    { id: 2, name: 'A2', salary: 500 },
    { id: 3, name: 'A3', salary: 1000 },
    { id: 4, name: 'A4', salary: 800 },
    { id: 5, name: 'A5', salary: 1300 }
];
employees.forEach(emp => console.log(emp));
employees.forEach(emp => console.log(emp.id, emp.name));
employees.forEach(({ id, name }) => console.log(id, name));

//Use case I want to print all employee name with lower case
//Transformation api : transform and return new array:pure funciton/immutablity
const transformedemps = employees.map(emp => emp.name.toLowerCase());
console.log(transformedemps)

//i need list of employees whose salary is less than 800
//filter : works on boolean

const filteredemps = employees.filter(emp => emp.salary <= 800);
console.log(filteredemps);

//Kindly findout how to add new element,delete,update element in the array

////////////////////////////////////////////////////////////////////////////////////////////

JSON: Javascript Object Notation:
.................................

History behind:
..............

In 2000, Ecommerce, Biz-Biz integration

2001 : Data interchange conference held

xml,json,text,tmp,yml..........................XML

2005 :  JSON

1.json is light weight than XML : Does not carry schema defintion only data
2.JSON is platform,language indendant.
3.JSON was discovered from Javascript literal object syntax.
  

JSON rules:

1.json files are string/text/ascii files.

2.JSON format is key ; value pair

  key : is string , must be enclosed only with "".
  value:
   should be , string,number,boolean,other literal object, array.

3.since json is text file, we need to extract data, and also we need to create json file
   -we need json parsers

The first parser is written by crock ford for javascript language :  json2.js

then after that many language vendors started adding json parsers in the language level or as third party lib.

ECMA 5 specfication , who added json parser in the language level. Now JSON parser is built in
ES 5, ES 6.

JS language provides parser as Object "JSON"   

Parser method

1.stringify :  OBject to string
2.parse : string object.


Parser :
   string to object
   object to string.
//JSON Parser

//Object
const employees = [
    { id: 1, name: 'A1', salary: 100 },
    { id: 2, name: 'A2', salary: 500 },
    { id: 3, name: 'A3', salary: 1000 },
    { id: 4, name: 'A4', salary: 800 },
    { id: 5, name: 'A5', salary: 1300 }
];
//Object to String
const str = JSON.stringify(employees);
console.log(str);

//String to Object
const obj = JSON.parse(str);
console.log(obj)
////////////////////////////////////////////////////////////////////////////////////////////

Math: Which has mathmetical operations.


//Math
console.log(Math.random())
console.log(Math.sign(10))
console.log(Math.pow(2,2))
///////////////////////////////////////////////////////////////////////////////////////////
How to handle runtime errors : exception handler

try..catch,finally
throw

//Exception handling

function validate(num) {
    try {

        if (num <= 10) {
            throw new Error('Number is less than 10')
        }
        console.log(`Num ${num}`);


    } catch (err) {
        console.dir(err);
    }
    finally {
        console.log('Done!')
    }
}
validate(12)
validate(1)

////////////////////////******************************///////////////////////////////////////

Scope chain and  this keyword:
..............................

Scope: visibility of variables ,functions,where it is visible

Types of scopes:

1.local scope
  The scope of the variable is  with in the function.
  Any thing is declared inside function is visible inside function only.

//local scope

function sayGreeter(){
    //local variables
    //var name = 'subramanian';
    let name ='Subramanian';   
    console.log(name);
    function sayHello(){
        console.log('Hello')
    }
}
//console.log(name);
sayHello();
sayGreeter();

2.block scope
 
in c++/java , if any thing you declare inside block is visible inside that block only.

function validate(name) {

    if (name) {
        //block
        var message = 'Hello'
    }
    console.log(message);
   // console.log(foo); //not defined

}
validate();



The above code will throw error for "foo"

  ReferenceError: foo is not defined :
     the variable is not declared no where.

 The above code will print undefined for variable message
 undefined :
     The variable is declared but no value.


The truth is javascript does not support block scope with "var" declaration.

How it is working :

source code : index.js

function validate(name) {

    if (name) {
        //block
        var message = 'Hello'
    }
    console.log(message);
   // console.log(foo); //not defined

}
validate();
     |
   parsing phase : parser change the original code
 

function validate(name) {
    var message; 
    if (name) {
        //block
        message= 'Hello'
    }
    console.log(message);
 }

  "The proces of moving variable declarations from blocks to functions at top position
     'Hoisting' "

What if i want to implement block scope?

1. Using IEFF functions : ES 5 Style

//avoiding hositing : using ieff functions
function validate(name) {
    if (name) {
        //block
        (function(){
            var message = 'Hello'
        })
    }
    console.log(message);
   // console.log(foo); //not defined

}
validate();

2.using let /const keyword

//avoiding hoisting using let/const keyword
function validate(name) {
    if (name) {
        let message = 'Hello';
    }
    console.log(message);
}

validate();

so, var vs let

var is hoisted
let is not hoisted.

Hoisting more eg:
//////////////////
//hositing eg

console.log(i);
var i = 10;
console.log(i);
//Parsed code
/**
 * var i;
 * console.log(i);
   i= 10;
   console.log(i);
 */

//console.log(x);
let x = 10;
console.log(x);

/**Parsed code
console.log(x);
let x =10;
console.log(x);
*/

myfun()//
var myfun= function(){
    console.log('Hoisting');
};
myfun()

//parsed code
 
/**
 * var myfun;
 * myfun()
 myfun= function(){
    console.log('Hoisting');
};
myfun()**/


literal function delclaration vs normal function declaration

normal functions will be hoistied by default
variable declarations with let never been hoisted, you cant even call before declarion.

sayHello();
function sayHello(){
    console.log('Hello')
}
sayHello();

/**
 * function sayHello(){
    console.log('Hello')
}
 * sayHello();
   sayHello();
 */

*****************************************************************************************
Three scopes in general: Based on variable declarations and binding

1.static scope /Lexical scope
2.dynamic scope
3.Augmented scope - deprecated


1.Static scope: (compile time in other languages)

Static scope

  Definition 1: 
    Static scope: a language implements static scope, if only by looking at the source code one can determine in which environment a binding is resolved.

   static scope is other wise is called lexcial scope 

Environment:
	Every execution context has an associated lexical environment.

Lexical environment: 
   A lexical environment is a structure used to define association between identifiers appearing in the context with their values. 


 Each environment can have a reference to an optional parent environment.

So an environment is a storage of variables, functions, and classes defined in a scope.


Context:
  Place / Container which contains other things

Environment : is also place which is inside context.

How code is intialized in java?
Hello.class-----load class into jvm---loader---loads .class file into jvm---Hello.class will
be initalized
    -it will see all static variables,methods --it will put inisde method method area
    -jvm will initalize meta object ---class Object : Hello.class
    -Heap new instance is created
       -Excution, we call methods....

How code is initalized in javascript?


Points :

in js every thing object , including your code.


 javascript wraps entire code into an object called "Context Object"

Execution context:
  Object which wraps js code.

There are several types of ECMAScript code: 

 "the global code, function code, eval code, and module code; each code is evaluated in its execution context"

1.Global Context
2.Funciton context
3.Eval Context
4.Module Context

Each Object has its own "enviroment"


Environment is a data structure which holds information about the
correponding context.

eg:
 if global context ====> Global Envirmonent
 if function context ===> Function enviroment.

Structure of Environent:

Technically, an environment is a key-value pair, consisting of an environment record (an actual storage table which maps identifiers(variables) to values), and a reference to the parent (which can be null).

Execution order / Relation ship order:

 GlobalEnv
	---parent=null 
   |
   bar 
      parent = global
    |
    zoo  
       parent = bar
      |
      myfun
        parent= zoo


variable resolution in the scope chain (env which forms chain looks like prototype chain)
.........................................................................................



//scope chain

//global scope
let x = 10;

function bar() {
    let y=9000;
    function zoo() {
        function myfun() {
            console.log(x);
            console.log(y);
        }
        myfun()
    }
    zoo()
}
bar();
//js scope chain loopkup
 // myfun record --->zoo record---bar record---global scope--|if not then throw error

     
This is called scope chain, or lexical scope.



When is lexical scope is fixed?


Two cycles in js

when visibility of a variable is activated.

   1.During initalization/creation 
           -Lexcial
   2.Execution time/activation?
   
.......................................***********.........................................

this keyword:
.............


Dynamic scope: Variable binding:

The dynamic scope specifically for variables is not widely used on practice today.

Definition : 
   Dynamic scope: a language implements dynamic scope, 
	if a "caller" defines an activation environment of a "callee".

caller =>Object
callee =>function

How to implement dynamic binding in js?
   
   "this" keyword.
  
what is "this" in general?
 
 "this" is implicit reference  variable.

types of reference variable

1.implicit
   this
 the value of this would "Object"
2.explicit
  emp is explicit
let emp = new Employee()



Defintion:
 "This value":
    in JavaScript this value is dynamically scoped
    "value of this" dynamically identified not in creation phase
    


Who supplies the value of this?

   The value of this is determined and provided exactly by the caller
   
   "The function binding is decided on object  dynamically".     

/////////////////////////////////////////////////////////////////////////////////////////
Implementation:
.................

variable binding:

Who can be owner of a?

 let a =10;

Global context : global scope
function context: function scope

 owner of a can be function, global

When the owner is identified?
 
 -Creation phase / initalization Phase
 -Exuction phase /Runtime Phase

.................................................

Who can be owner of sayHello?

function sayHello(){
    return this;
}

"The value of 'this' only owner of sayHello".

How and when owner of sayHello is decided?

Browsers:

1.By default , in browser sayHello belong to window.

Binding with window object in browser , which is more danager which will lead code corruption
which is one of the javascript bug : Global scope.

in order to fix bug: javascript introduced a concept 'strict' mode
 in strict mode , any javascript language level bugs will be disabled automatically,
so we can write quality code 

Points:
1.in non strict mode , this bound to window , I mean sayHello
 is bound on window object by default. 
2.In strict mode, this bound is decided by us based on object 
  binding , meaning that function is free from any Object  binding default : this is recommended.


Think: can "this" be bound with function "Creation phase"  
       or can "this" be available in lexical scope?
       or can "this" be available in static scope?
                  No!



Use case 1 : how to bind function dynamically  | how to initalze "this" dynamically"
             how to decide the owner of the function?

How to call function on objects dynamically?

'use strict'

function sayHello(){
    return this; //owner 
}
console.log(sayHello());
//Tell who is the owner of sayHello.
//Use case 1 : i am going to tell window is owner
console.log(sayHello.call(window));
//sayHello can be part of any other object

const greeter= {
   message:'Hello'
};
console.log(sayHello.call(greeter));


Function object provides  function binding apis
1.call
2.apply
3.bind


//call,apply,bind :  these api will plugin the funtions 
//on to the objects dynamically with help of this keyword.
'use strict';

function getCordinate(...name) {
    console.log(` ${name} ${this.x} y ${this.y}`)
}

const map = {
    x: 1000,
    y: 3888
}
window.x = 90;
window.y = 899;

// .call(target,parameter1,parameter2...)
getCordinate.call(map, 'GooogleMap', 'goolge');
getCordinate.call(window, 'Window', 'chrome');
/////////////////////////////////////////////////////////////////////////////
//apply

function getStocks(...stocks) {
    console.log(`${this.name}`)
    console.log(stocks);
}
const stock = {
    name: 'Sony'
};
//apply
getStocks.apply(stock, [10, 20, 30, 40, 45])
//call vs apply : call takes separate parameters, where as apply takes array as parameter
////////////////////////////////////////////////////////////////////////////////
//bind vs call and apply : bind never executes function immediatly rather which returns
//copy of the function of the function only : lazy invocation
//call and apply invocation is eager invocation.


function increment() {
    return this.count++;
}
const CounterApp = {
    count: 0
}
const inc = increment.bind(CounterApp)

for (let i = 0; i < 10; i++) {
    console.log('counter', inc())
}
////////////////////////////////////////////////////////////////////////////////////////////

Nested scope and this keyword:
.............................

Arrow functions and this keyword:
................................

In general the value of "this" for function is dynamically scoped.

but in 

Arrow function in strict or non-strict mode , the value of this is staticly /lexically
scoped.

  'use strict'

const training = {
    firstName: 'Subraamanian',
    teach: function () {
        //How to access instance variable 'firstName' inside nested
        //function

        // way 1 : calling on object directly
        /**function teachJs() {
            console.log(`Name ${this.firstName} `);
        }
        teachJs.call(training);**/

        //way 2: using self semantic concept : short cut
        // let self = this;
        // function teachJs() {
        //     console.log(`Name ${self.firstName} `);
        // }
        // teachJs.call(training);
        //
        //let teachJs = () => console.log(`Name ${this.firstName} `);
        // teachJs();
        return () => console.log(`Name ${this.firstName} `);

    }
}
let teachJs = training.teach();
teachJs();
//teachJs.call(training);

/////////////////////////////////////////////////////////////////////////////////////////////

Public scope:
.............

 All instance variables and methods inside object , has public scope.

/////////////////////////////////////////////////////////////////////////////////////////////

Node JS:
.......

1.node architecture
2.Async programming
/////////////////////////////////////////////////////////////////////////////////////////

                                   Node.js /node
.............................................................................................

What is node.js?

 Node is javascript runtime to run javascript applications.

 Node is javascript runtime written on google V8 JAVASCRIPT engine.

Histroy behind node?

Ryan Dahl who created Node js in 2007 -2008 .

Why Ryan created node js?

 He wanted to create webserver which supports nonblocking/async webserver

Node is was created to build non-blocking IO applications.
////////////////////////////////////////////////////////////////////////////////////////////

Blocking and Non blocking:
..........................


Multi threading:

What is thread?


 It is sub process , which is running on process.
 It shares process memory and resources
 It can exchange data easily.
 
Since it is subprocess, which must have some layout /Structure.


How is thread is created?

function sayHello(){


}
sayHello() // pushed into stack---->Stack frame(thread of execution)


by calling function and pushing inside stack, becomes live method execution.

/////////////////////////////////////////////////////////////////////////////////////////////

project setup:

mkdir mynode-apps

cd mynode-apps

mkdir src




while one frame is running, the other frames are "waiting" 


How to run multiple frames?
  Multi threading.

Thread manager runs any one of the frame at same time,remaining frames are passive.

Role of Process:

1.creating multiple threads
2.running all the threads
3.managing life cycles of threads.

if process is doing the above job, we call "Process Level Concurrency/Process multi threading"


Does Node and javascript support process level multi threading?

  NO!

What is the problem with process level threads?

evils of multi threading:
...................................

1.dead lock
2.thread stravation
3.thread race conditions
4.resources waste
5.threads can block itself


   "java script is single threaded and node is also single threaded model"


What if javascript and node does not support multi threading then how to achive concurrency?

               "Worker-thread Model / Async Programming"



Types of Concurrency:

1.Process Level Concurrency : this is tradtional , java /c++ follows

2.Worker-Thread level concurrency / Event driven concurrency/ Event loop concurrency /Worker-thread Model / Async Programming
   - javascript.

1.Process Level Concurrency :

Threads are created  by the process itself
Threads are executed  by the process itself
Threads are destroyed by the process itself


what is difference between java like env and javascript with respect to multi threading.

javascript uses worker thread model
   Loose coupling
   you need not manage all thread drawabacks.


java uses process level thread model

////////////////////////////////////////////////////////////////////////////////////////////

Use case For Process level multi threading and Worker thread Model concurrency:
////////////////////////////////////////////////////////////////////////////////


Web Server:
.............

JavaWebServer

Client----------------request-----             -thread----reading 1 gb file
Client----------------request-----  WebServer---thread ---read 1 million db records
Client----------------request-----             -thread ---read simple json file
Client----------------request-----             -thread ----read simple html file

 The above cycle,
 what if a thread is taking longer time to read file lets say 1 gb file.
   then web server will be blocked : Blocking Mode

///////////////////////////////////////////////////////////////////////////////////////

NonBlocking  /Worker Thread Model:

                                                            OS Kernal threads
Client----------------request-----                         thread----reading 1 gb file
Client----------------request-----  |WebServer---|         thread ---read 1 million db records
Client----------------request-----                         -thread ---read simple json file
Client----------------request-----                         -thread ----read simple html file


Node will offload heavy computation into OS kernal parts


How results are returnted to end user:


                                          
                                          Events           OS Kernal threads

Client----------request-----                 <--emit event thread----reading 1 gb file
Client---------request-----  |WebServer--->| <--emit event thread ---read 1 million db records
Client---------request-----                                thread ---read simple json file
Client---------request-----                                thread ----read simple html file


once thread has completed its job in the os, it will emit a signal(events) to Node process


How events are handled?

                                
                             Event Queue and Event loop    Events           OS Kernal threads

Client---request-----                             <--emit event thread----reading 1 gb file
Client---request-----  | WebServer<---Queue|loop  <--emit event thread ---read 1 million db 
Client-- request-----                                thread ---read simple json file
Client-- request-----                                thread ----read simple html file

////////////////////////////////////////////////////////////////////////////////////////////



Your taks---Node---will offload to OS

OS--return data to node ---events-----event loop---|eventQueue---Stack----->client
/////////////////////////////////////////////////////////////////////////////////////////////


Node js Components:

Node is collection of many libs

 1.v8
 2.libuv
////////////////////////////////////////////////////////////////////////////////////////////

How to write nonblocking/async programming?

Two setup


1.you need high level non blocking api which must have low level non blocking api.


function add(){

}
add()---async api

common non blocking apis:

1.timers
  settimeout,setinterval

2.IO apis
   ->fs
   ->network



2.You need to pass function  as parameter

   callback or listner , which handles result of async operation.
/////////////////////////////////////////////////////////////////////////////////////////////

Lets code:

Timers:

How write non blocking code?

 in order to write non blocking we have different styles


1.callback style

2.Promise style

3.Async await style






//async api : timers: setTimeout 

//Flow
/**
 * setTimeout(cb,1000)
 *  |
 *  ---->stack----->V8 takes decision that whether settimemout is sync or async
 *   |
 *   Async
 *    ---------->libuv
 *                  |
 *                  -----POST-----to----------OS
 *      Program control is returned to main Process
 *  node starts executing next line of code and so on...
 *    while node is running
 *             ---emits a signal of completion-----<----------<-------------os
 *    now libuv event loop starts processing signal(event)
 *          --->attach signal with callback function which is present in Event
 *                Queue
 *     then loop verfies whether stack is empty
 *           |
 *           Yes
 *             -->callback function is pushed, result is returned to main program
 * 
 */

function sayHello() {
    console.log('hello!');
}
console.log('start')
setTimeout(function () {
    console.log('I am delayed function!')
}, 1000);
sayHello();

////////////////////////////////////////////////////////////////////////////////////////////


//timer versions

//setTimeout(function () { console.log('im delay') }, 1000);

// let handler = function () {
//     console.log('Hello i delayed');
// };
// setTimeout(handler, 1000);

//arrow version
//setTimeout(() => console.log('Hello iam delayed'), 1000);
setTimeout(name => console.log(`${name} am delayed`), 1000, 'Subramanian');

//////////////////////////////////////////////////////////////////////////////

const sayGreet = callback => {
    let name = 'subramanian'
    //setTimeout(callback, 3000, name);
    setTimeout(() => {
        callback(name)
    }, 1000);
};
sayGreet(name => {
    console.log(`${name} am delayed function!`)
});
////////////////////////////////////////////////////////////////////////////////////
//timer with biz logic : i want to create simple async application with timer

const getUser = (success, failure) => {
    let user = {
        id: 1,
        name: 'admin'
    }
    let error = {
        message: 'User not found',
        code: 500
    }
    //biz logic
    if (user) {
        setTimeout(success, 1500, user);
    } else {
        setTimeout(failure, 1500, error) //error handling
    }
}
getUser(user => console.log(user), err => console.log(err));

//////////////////////////////////////////////////////////////////////////////////

//what if two settimeout having same timeout :
//output is based registeration who has registered first
setTimeout(name => console.log(`${name} am delayed`), 500, 'Subramanian');
setTimeout(name => console.log(`${name} am delayed`), 500, 'Ram');
//////////////////////////////////////////////////////////////////////////////
//can we have 0 ms as timeout , what will happen
   //0ms is not timer, at least one time it should be processed by event loop.
setTimeout(name => console.log(`${name} am delayed`), 0, 'Geetha');


/////////////////////////////////////////////////////////////////////////////////////////

setinterval:
  set interval starts ticking  timer based on parameter specified in the api.


//set interval
let counter = 0;
const handler = () => {
    counter += 1;
    console.log(counter)
}
console.log('start')
let timerId = setInterval(handler, 1000);

//Stop the timer after 10000ms
//setTimeout(clearInterval, 10000, timerId);
setTimeout(() => clearInterval(timerId), 10000);

console.log('end')
////////////////////////////////////////////////////////////////////////////////////////////

Callback Patterns;
...................

callback/handler : 

 it is function , which will be called after  async operation is completed.
 it is passed as parameter to another function 
 It is registered during intializations.

1.nested callbacks
2.callback hell

Nested Callbacks:

   Callback inside another callback.
What is use case of nested callback?
->chaining operation.
  The outout of one callback, will be input to another callback



//nested callback.
//resolve = successhandler
//reject  =ErrorHandler
const getUser = (resolve, reject) => {
    //biz logic
    let fakeUser = {
        id: 1,
        name: 'admin'
    };

    if (fakeUser) {
        console.log('Get User is called!');
        setTimeout(resolve, 1000, fakeUser);
    } else {
        setTimeout(reject, 1000, { id: 500, err: 'User not found!' });
    }
};

//login
const login = (user, resolve, reject) => {
    //biz logic 
    if (user.name === 'admin') {
        console.log('Login is called!');
        setTimeout(resolve, 1000, `login success`);
    } else {
        setTimeout(reject, 1000, { id: 500, err: 'Login failed' });

    }
}

getUser(user => {
    //output of get User will be input to the login.
    login(user, status => {
        console.log(status)
    }, err => {
        console.log(err);
    });
}, err => {
    console.log(err);
})
///////////////////////////////////////////////////////////////////////////////////////////

Callback Hell:


//nested callback.
//resolve = successhandler
//reject  =ErrorHandler
const getUser = (resolve, reject) => {
    //biz logic
    let fakeUser = {
        id: 1,
        name: 'admin'
    };

    if (fakeUser) {
        console.log('Get User is called!');
        setTimeout(resolve, 1000, fakeUser);

    } else {
        setTimeout(reject, 1000, { id: 500, err: 'User not found!' });
    }
};

//login
const login = (user, resolve, reject) => {
    //biz logic 
    if (user.name === 'admin') {
        console.log('Login is called!');
        setTimeout(resolve, 1000, { user, status: 'login Success' });
    } else {
        setTimeout(reject, 1000, { id: 500, err: 'Login failed' });

    }
}

const showControlPanel = (user, resolve, reject) => {
    //biz logic 
    if (user.name === 'admin') {
        console.log('control panel is called is called!');
        setTimeout(resolve, 1000, `You have landed Control Panel`);
    } else {
        setTimeout(reject, 1000, 'You have landed Guest Page');

    }
}

getUser(user => {
    //output of get User will be input to the login.
    login(user, response => {
        console.log(response.status)
        showControlPanel(response.user, msg => {
            console.log(msg)
        }, guestMessage => {
            console.log(guestMessage)
        });
    }, err => {
        console.log(err);
    });
}, err => {
    console.log(err);
})


Questions:

1.Whether this code is able to understand quickly
2.Whether this code is able to debug
3.Whehter this code is scalable?
4.whether this code is maintaiable?

"No" : This is what we call as "Callback hell".



fs.readdir(source, function (err, files) {
  if (err) {
    console.log('Error finding files: ' + err)
  } else {
    files.forEach(function (filename, fileIndex) {
      console.log(filename)
      gm(source + filename).size(function (err, values) {
        if (err) {
          console.log('Error identifying file size: ' + err)
        } else {
          console.log(filename + ' : ' + values)
          aspect = (values.width / values.height)
          widths.forEach(function (width, widthIndex) {
            height = Math.round(width / aspect)
            console.log('resizing ' + filename + 'to ' + height + 'x' + height)
            this.resize(width, height).write(dest + 'w' + width + '_' + filename, function(err) {
              if (err) console.log('Error writing file: ' + err)
            })
          }.bind(this))
        }
      })
    })
  }
})

                   "callback is other wise called as doom of pyrbid."

//////////////////////////////////////////////////////////////////////////////////////////
 
How to fix the callback hell? How to write better callback programming? or How to avoid callback hell?

In 2005, JQUERY team started with working complex callback patterns, they found callback
hell problem.

They proposed a  Design pattern to write better callback programming(Async) programming.

  "promise".

Implementation of "promise" design pattern:
...........................................



SInce Promise is design pattern, many people have implemented Promise design pattern.

1.JQuery -first promise implementation
2.many libs and frameworks

Because of popularity of promise design pattern, ECMA 6 ,ES 6 

IN 2012 ecma Commit introduced "Promise" as Object in javascript.


ES 6 "Promise" Object is the reference implementation of "promise" Design pattern.


features of Promise Object:
............................

1.Promise by deafult is Async. Which implements timer api with 0 ms .

Promise can be used with any async implementations.


Promise ES 6 implementation:

IN ES 6 promise Object.

Promise object creation:

1.Using factory apis - 
   Promise.resolve() =>Promise
   Promise.reject() =>Promise
2.Using constructors
   new Promise(parameter)


Common Methods in Promise Object:

1.then:
   Handler method to handle async operation success results.
2.catch:
   Handler method to handle async operation error results
3.finally
   Handler method is used for clean /completion status method

Advanced Methods

4.all
5.any
6.race


Basic Promise Object creations:
..............................
//Promise Object creations

//Using factory methods

//Only Success

function getInfo() {
    return Promise.resolve('Info'); //Promise Object
}
// console.log('start');
// let pro = getInfo();
// //Get Async Result
// pro.then(res => console.log(res));
// console.log('end');

//short cut to get Promise : Builder Pattern/CommandChain Pattern.

// getInfo()
//     .then(res => console.log(res));

getInfo()
    .then(console.log);
////////////////////////////////////////////////////////////////////////////////////
//Only error

function getError() {
    return Promise.reject('Something went Wrong!!!');
}
getError().catch(console.log)
///////////////////////////////////////////////////////////////////////////////////
//Promise.resolve and reject 

const getUser = () => {
    let fakeUser = {
        id: 1,
        name: 'admin'
    };
    if (fakeUser) {
        return Promise.resolve(fakeUser);
    } else {
        return Promise.reject({ code: 500, err: 'User not Found!!' });
    }
};
getUser()
    .then(console.log)
    .catch(console.log)
    .finally(() => console.log('getUser Async Operation has been done!!!'));
//////////////////////////////////////////////////////////////////////////////////////////////
//promise constructors:
/**
 * 
 * Use case cases /When to use Promise:
 * 
 * 1.if your application is already in callback based
 * or
 * 2.if you want to convert any callback based programming
 *  into promise Powered
 * 
 * Solution is Promise Constructors
 * 
 */

//Callback based programmning: timer

//I have tick function which returns async result to the caller

/**function tick(success, failure) {

    let isEnabled = true;
    if (isEnabled) {
        setTimeout(success, 1000, 'Server is Started');
    } else {
        setTimeout(failure, 1000, 'Server is Failed')
    }
}


//caller
function startServer() {
    tick(status => {
        console.log(status);
    }, err => {
        console.log(err);
    });
}
startServer();
**/
//Promise Version
function tick() {
    let isEnabled = true;
    //wrap the code into Promise
    return new Promise((resolve, reject) => {
        if (isEnabled) {
            setTimeout(resolve, 1000, 'Server is Started');
        } else {
            setTimeout(reject, 1000, 'Server is Failed')
        }
    });
}

//caller
function startServer() {
    tick()
        .then(console.log)
        .catch(console.log)
        .finally(() => console.log('Async Opertion is done!'))
}
startServer();
/////////////////////////////////////////////////////////////////////////////////////////


Nested Promises:
...............

//Promise Chaining :The output of one Promise is Input to another Promise:

//Promise Chaining :The output of one Promise is Input to another Promise:


const getUser = () => {
    let fakeUser = {
        id: 1,
        name: 'admin'
    };
    if (fakeUser) {
        return Promise.resolve(fakeUser);
    } else {
        return Promise.reject({ code: 500, err: 'User not Found!!' });
    }
};
const login = user => {
    if (user.name === 'admin') {
        return Promise.resolve({ user, message: 'Login Success' });
    } else {
        return Promise.reject({ code: 500, err: 'Login failed!' });
    }
};

function startApp() {
    // getUser()
    //     .then(user => {
    //         console.log('Get User method is called')
    //         return login(user);
    //     })
    //     .then(console.log)
    //     .catch(console.log)
    //     .finally(() => {
    //         console.log('Async Operation is Completed!!!');
    //     });
    // getUser()
    //     .then(user => login(user))
    //     .then(console.log)
    //     .catch(console.log)
    //     .finally(() => {
    //         console.log('Async Operation is Completed!!!');
    //     });

    const { log } = console;
    getUser()
        .then(login)
        .then(log)
        .catch(log)
        .finally(() => {
            log('Async Operation is Completed!!!');
        });
}
startApp();

///////////////////////////////////////////////////////////////////////////////////////////

Promise Hell:
.............
 When we nest so many Promise abstraction which will give use Promise Hell.


//Promise Chaining :The output of one Promise is Input to another Promise:


const getUser = () => {
    let fakeUser = {
        id: 1,
        name: 'admin'
    };
    if (fakeUser) {
        return Promise.resolve(fakeUser);
    } else {
        return Promise.reject({ code: 500, err: 'User not Found!!' });
    }
};
const login = user => {
    if (user.name === 'admin') {
        return Promise.resolve(user);
    } else {
        return Promise.reject({ code: 500, err: 'Login failed!' });
    }
};

const showControlPanel = user => {
    if (user.name === 'admin') {
        return Promise.resolve(`You have landed Control Panel`);

    } else {
        return Promise.reject('You have landed Guest Page');
    }
}

function startApp() {
    // getUser()
    //     .then(user => {
    //         console.log('Get User method is called')
    //         return login(user);
    //     })
    //     .then(console.log)
    //     .catch(console.log)
    //     .finally(() => {
    //         console.log('Async Operation is Completed!!!');
    //     });
    // getUser()
    //     .then(user => login(user))
    //     .then(console.log)
    //     .catch(console.log)
    //     .finally(() => {
    //         console.log('Async Operation is Completed!!!');
    //     });

    const { log } = console;
    getUser()
        .then(login)
        .then(showControlPanel)
        .then(log)
        .catch(log)
        .finally(() => {
            log('Async Operation is Completed!!!');
        });
}
startApp();
/////////////////////////////////////////////////////////////////////////////////////

How to fix Promise Hell?

ES 7 introduced  new Keywords called "async and await keywords".

async is keyword to used in front of functions
we call as async functions.


Features of asyncfunctions:


1.async function by default return Promise Object by calling Promise.resolve.


//Async functions

async function getInfo() {
    return 'Info';    //Promise.resolve('Info'); //Promise Object
}
//calling async function
const { log } = console;
getInfo().then(log);

async function getError() {
    return Promise.reject('Something went Wrong!!!');
}
getError().catch(log)
//////////////////////////////////////////////////////////////////////////////////
const getUser = async () => {
    let fakeUser = {
        id: 1,
        name: 'admin'
    };
    if (fakeUser) {
        return fakeUser;
    } else {
        return Promise.reject({ code: 500, err: 'User not Found!!' });
    }
};
getUser()
    .then(log)
    .catch(log)
    .finally(() => log('getUser Async Operation has been done!!!'));
///////////////////////////////////////////////////////////////////////////////

await :

//async ---await
//await is going to eleminate then calls.
//await will return result of async operation or may return another promise in nested
//await keyword tells "sync style of async operation"

//Returns Promise
function getInfo() {
    return Promise.resolve('Info');
}
function getError() {
    return Promise.reject('Something went Wrong!!!');
}

const getUser = async () => {
    let fakeUser = {
        id: 1,
        name: 'admin'
    };
    if (fakeUser) {
        return fakeUser;
    } else {
        return Promise.reject({ code: 500, err: 'User not Found!!' });
    }
};
const { log } = console;
async function getInfoResult() {
    // getInfo().then(result=>console.log())
    const result = await getInfo();
    log(result);
}
getInfoResult()

async function getErrorResult() {
    try {
        const result = await getError();
        log(result);
    } catch (err) {
        log(err);
    }
}
getErrorResult()

async function getUserResult() {
    try {
        const user = await getUser();
        log(user);
    } catch (err) {
        log(err);
    } finally {
        console.log('done!')
    }
}
getUserResult();
///////////////////////////////////////////////////////////////////////////////

//Promise Chaining :The output of one Promise is Input to another Promise:


const getUser = () => {
    let fakeUser = {
        id: 1,
        name: 'admin'
    };
    if (fakeUser) {
        return Promise.resolve(fakeUser);
    } else {
        return Promise.reject({ code: 500, err: 'User not Found!!' });
    }
};
const login = user => {
    if (user.name === 'admin') {
        return Promise.resolve(user);
    } else {
        return Promise.reject({ code: 500, err: 'Login failed!' });
    }
};

const showControlPanel = user => {
    if (user.name === 'admin') {
        return Promise.resolve(`You have landed Control Panel`);

    } else {
        return Promise.reject('You have landed Guest Page');
    }
}

const { log } = console;
async function startApp() {
    try {
        const user = await getUser();
        await login(user);
        const ctlPanel = await showControlPanel(user);
        log(`${user.name} ${ctlPanel}`);
    }
    catch (err) {
        log(err)
    } finally {
        log('done!')
    }
}
startApp();
********************************************************************************************

Javascript Modules and node Modules:
....................................

What is modularity?

1.how to break app into multiple files
2.after breaking how to share code among files.

      "Organization of code"

Java:
Java modularity is based on folder and file structure
 -Phy modualirty
 
 e:/myapp/src/
         com/sony/digital/games/Player.java 

Java modularity is based on  packages
 -logical modularity

 package com.sony.digital.games

 class Player{

 }

Linking :

 import com.sony.digital.games.Palyer;

 class Game {
   Player player;
}

Javascript:

javascript modularity is file based
  index.js
  <script src="index.js">

logical modularity?

  function() or {} or class ?

Points :

1.js modularity is very very weak   why , js was not created for enterprise computing
  -large scale programming.

once javascript was  started growing , devs thought how to write modular code?

 
How to solve this issue?

Via module design patterns.

1.Namespace design pattern : which is core design pattern helps to organize code sharing only
  ->how to encapsulate the code
 which uses js core concept called "literal object/iife)"

2.AMD 
  It is first professional design pattern, which talks how to organize the code and how 
  to link files and how to share code

3.CJS : Common JS
  It was born from amd and namespace.
  This design pattern implemented in node js by default.
 
4.ES 6 Module design pattern
  It was created by ECMA Committe 
  ES 6  =  namespace + amd + cjs

//////////////
5.System

6.UMD

It is not used for development but used by tools for build interoperaable.
///////////////////////////////////////////////////////////////////////////////////////////

The above design patterns only, which talks how to organize code ,how to link files?

Does js engine understand these design patterns?

 No!.

We need module loaders, loaders are spcial javascript lib.


Node.js has built in CJS loader, so we can write cjs code directly without any extra loader
lib.

Node does not support es 6 modules directly, so if want to run e6 modules, we need loader.
///////////////////////////////////////////////////////////////////////////////////////////

Common JS : cjs:
.................

cjs recommends three keywords

1.require
2.exports
3.module.exports


How to link files
  require is function which is already implemented on node js.
  require('jsfilepath')

How to share code among files
 exports
 module.exports

eg;
linking files

src/mylib.js
//how to link
require('./mylib')

src/index.js
//how to link
require('./mylib')

///////////////////////////////////////////////////////////////////////////////////////

How to share code among files?

code :

 variable declaration with any literal
 function declaration
 class declaration

sharing code via:

exports
 
1.exports is variable , provided by cjs implemenation.
  let exports=value?
2.exports variable is declared inside a function called
  "require"


module.exports



//////////////////////////////////////////////////////////////////////////////////////////


require Demo:


src/lib/mylib.js
//Code 
//name and city
/**
 * function  require(filePath){
 *  let exports = {};
 * 
 *  exports.name = 'Subramanian'
 *
 *
 *  return exports;
 * }
 *
 */
exports.name = 'Subramanian'
exports.city = 'Coimbatore';
exports.id = 10;
exports.isActive = true;
exports.skills = ['javascript', 'Node', 'MicroServices'];
exports.calculate = function () {
    return 1000;
}


src/index.js
//how to link
// const result = require('./libs/mylib')

// console.log(result);

// console.log(result.name)
// console.log(result.id);
// console.log(result.skills);
// console.log(result.isActive);
// console.log(result.calculate())

const { name, id, skills, isActive, calculate } = require('./libs/mylib')
console.log(name)
console.log(id);
console.log(skills);
console.log(isActive);
console.log(calculate())

/////////////////////////////////////////////////////////////////////////////////////////

module.exports;

1.it does not return object like exports

2.code is not packed inside object 

3.What you return, the same thing will be returned
  if you return variable, it will variable
  if you retun function , it will function.

4.it does not return multiple things.


src/libs/

Customer.js


class Customer {
    constructor(id, name) {
        this.id = id;
        this.name = name;
    }
}
module.exports = Customer;

employee.js


module.exports = [
    { id: 1, name: 'A1' },
    { id: 2, name: 'A2' },
    { id: 3, name: 'A3' }
]

greeter.js


// function sayGreeter() {
//     return 'Greet';
// }

// module.exports = sayGreeter;

module.exports = function () {
    return 'Greet';
}

variablereturn.js




//module.exports

/**
 * function require(filePath){
 *  let exports = {};
 *  let module.exports; //undefined
 * 
 *  if(!exports)
 *  {
 *   module.exports =variable
 * 
 *   return variable
 *   
 *  }
 *  return exports
 * 
 * }
 * 
 * 
 */
const name = 'Subramanian';

module.exports = name;

index.js

const firstName = require('./libs/variablereturn');
const greet = require('./libs/greeter');
const employees = require('./libs/employees');
const Customer = require('./libs/Customer');

console.log(firstName)
console.log(greet());
console.log(employees)
let { id, name } = new Customer(1, 'subramanian')
console.log(id, name);
////////////////////////////////////////////////////////////////////////////////////////

TodoApp :

const TODOS = require('../mock-data/Todos');

class TodoService {
    constructor() {
        console.log('Todo Service is being initalized!!!');
    }
    //sync api
    // findAll(){
    //     return TODOS
    // }
    //async api ; callback pattern
    // findAll(callback) {
    //     setTimeout(callback, 1000, TODOS);
    // }
    //async api : promise Pattern

    findAll() {
        return new Promise((resolove, reject) => {
            setTimeout(resolove, 1000, TODOS);
        });
    }

}

module.exports = new TodoService();


const { findAll } = require('./services/TodoService');


async function fetchAllTodos() {
    //sync api
    //findAll().forEach(console.log)

    //async api call : callback pattern
    //   findAll(todos=>{
    //       console.log(todos)
    //   });
    //async api with promise
    //findAll().then(console.log);
    //async api with await 
    const todos = await findAll();
    console.log(todos);
}

fetchAllTodos();

  
//////////////////////////////////////////////////////////////////////////////////////////

1.Node modules

Types of modules:
.................

1.custom node module
  we have discussed
2.in built  node modules
3.third party node modules


Note : any module , just javascript files, having code.

2.in built  node modules:

 node modules provided by node installation.


1.operating system

const {arch,hostname,platform} = require('os')

console.log('Operating System information');
console.log(arch())
console.log(hostname())
console.log(platform())


 require('os') vs require('./greeter');
                     
without ./ means, node runtime uses env settings to lookup js files automatically
./ means , lookup js files in the current dir.



how node look up js files?

node will look up files in this order

  project-folder
             ---node_modules	
			---not present
				 |
				node installation folder(c drive)
					|
					node_modules
						|
						 present : load those files
					else
					  - throw errors.



C:\session\sony\mynode-apps>node src/index.js
internal/modules/cjs/loader.js:800
    throw err;
    ^

Error: Cannot find module 'oxxxs'
Require stack:
- C:\session\sony\mynode-apps\src\index.js
[90m    at Function.Module._resolveFilename (internal/modules/cjs/loader.js:797:15)[39m
[90m    at Function.Module._load (internal/modules/cjs/loader.js:690:27)[39m
[90m    at Module.require (internal/modules/cjs/loader.js:852:19)[39m
[90m    at require (internal/modules/cjs/helpers.js:74:18)[39m
    at Object.<anonymous> (C:\session\sony\mynode-apps\src\index.js:1:34)
[90m    at Module._compile (internal/modules/cjs/loader.js:959:30)[39m
[90m    at Object.Module._extensions..js (internal/modules/cjs/loader.js:995:10)[39m
[90m    at Module.load (internal/modules/cjs/loader.js:815:32)[39m
[90m    at Function.Module._load (internal/modules/cjs/loader.js:727:14)[39m
[90m    at Function.Module.runMain (internal/modules/cjs/loader.js:1047:10)[39m {
  code: [32m'MODULE_NOT_FOUND'[39m,
  requireStack: [ [32m'C:\\session\\sony\\mynode-apps\\src\\index.js'[39m ]
}

///////////////////////////////////////////////////////////////////////////////////////////

events:

Much of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called "emitters") emit named events that cause Function objects ("listeners") to be called.

Node is event driven architecture.
Node supports event driven programming
In node most of the IO apis are powered with events.
Event driven progam is other wise called pub/sub pattern.

How to create custom event driven programming?

node provides a module called events.

////////////////////////////////////////////////////////////////////////////////////////

Events module provides a class , y create object

EventEmitter Object methods

1.on
  bind event
2.emit
  send event


const EventEmitter = require('events');

//create Object 
const event = new EventEmitter();

//Bind event
event.on('tick', data => console.log(data));

//emit event:
event.emit('tick', 'Hey')
//with timer , lets say i want to emit event after few seconds
setTimeout(() => event.emit('tick', 'I am late!'), 1000);
////////////////////////////////////////////////////////////////////////////////
//Event Emitter with domain objects

class Inventory extends EventEmitter {
    constructor() {
        super();
        this.on('sale', product => console.log(product));
    }
    //add biz method
    update(product) {
        this.emit('sale', product);
    }
}
//create object

let inv = new Inventory();
inv.update({ id: 1, name: 'Medicine' });
///////////////////////////////////////////////////////////////////////////////////////////

IO applications:
................
Node is used to build non block io.

 Node initallly desinged for non blocking.

Does node support blocking io?
  Yes!
Blocking io is very danagerous.
  but still node supports, dont unnecessarly use blocking io code in app.

How node supports blocking io?
  Via "Thread Pools".

////////////////////////////////////////////////////////////////////////////////////////////


How to read file through nonblocking way?


//non blocking io
const fs = require('fs');

const filePath = './src/assets/info.txt';
const options = {
    encoding: 'utf-8'
}
console.log('start')
fs.readFile(filePath, options, (err, data) => {
    if (err) throw err;
    console.log(data);
});
console.log('end')


/////////////////////////////////////////////////////////////////////////////////////

FileService app:

const fs = require('fs');

class FileService {
    constructor() {
        console.log('File Service api is init')
    }
    //biz api
    read() {
        const filePath = './src/assets/info.txt';
        const options = {
            encoding: 'utf-8'
        }
        //Promise Wrapper
        return new Promise((resolve, reject) => {
            fs.readFile(filePath, options, (err, data) => {
                if (err) {
                    reject(err);
                }
                resolve(data);
            });
        });


    }
}


module.exports = new FileService();

index.js
const { read } = require('./services/FileService');


//api
async function readFile() {
    try {
        const fileContent = await read();
        console.log(fileContent);
    }
    catch (err) {
        console.log(err);
    }
    finally {
        console.log('file operation done!')
    }
}
readFile();
//////////////////////////////////////////////////////////////////////////////////////////////
Node Globals:


Global Objects:
...............
1.process
2.JS objects-math,date....
3.exports
4.module


Global Variables:

5.__dirname
      ->Get current dir path
6.__filename
     ->Get current dir + path__filename
     ->Get current dir + path


How to deal with file paths?

 node provides a module called "path"

The path module provides utilities for working with file and directory paths.
It can be accessed using:
const path = require('path');


const fs = require('fs');
const path = require('path');


class FileService {
    constructor() {
        console.log('File Service api is init')
    }
    //biz api
    read() {
        //const filePath = './src/assets/info.txt';
        const filePath = path.join(__dirname, '../assets/info.txt')
        const options = {
            encoding: 'utf-8'
        }
        //Promise Wrapper
        return new Promise((resolve, reject) => {
            fs.readFile(filePath, options, (err, data) => {
                if (err) {
                    reject(err);
                }
                resolve(data);
            });
        });
    }
    write(data) {
        const filePath = path.join(__dirname, '../assets/details.txt')
        const options = {
            encoding: 'utf-8'
        }
        return new Promise((resolve, reject) => {
            fs.writeFile(filePath, data, err => {
                if (err) {
                    reject(err);
                }
                resolve(`${filePath} Successfully written!`);
            });
        });
    }
}


module.exports = new FileService();


const { read, write } = require('./services/FileService');


//api
async function readFile() {
    try {
        const fileContent = await read();
        console.log(fileContent);
    }
    catch (err) {
        console.log(err);
    }
    finally {
        console.log('file read operation done!')
    }
}
async function writeFile() {
    try {
        const data = 'Hello How are you!';
        const status = await write(data);
        console.log(status);
    } catch (err) {
        console.log(`File write error ${err.code}`)
    }
    finally {
        console.log('file write operation done!')

    }
}

readFile();
writeFile();

/////////////////////////////////////////////////////////////////////////////////////////////

const { read, write, writeJSON } = require('./services/FileService');
const TODOS = require('./mock-data/Todos');

//api
async function readFile() {
    try {
        const fileContent = await read();
        console.log(fileContent);
    }
    catch (err) {
        console.log(err);
    }
    finally {
        console.log('file read operation done!')
    }
}
async function writeFile() {
    try {
        const data = 'Hello How are you!';
        const status = await write(data);
        console.log(status);
    } catch (err) {
        console.log(`File write error ${err.code}`)
    }
    finally {
        console.log('file write operation done!')

    }
}

async function writeJsonFile() {
    try {
        const status = await writeJSON(TODOS);
        console.log(status);
    } catch (err) {
        console.log(`File write error ${err.code}`)
    }
    finally {
        console.log('file write operation done!')

    }
}

//readFile();
//writeFile();
writeJsonFile();

////////////////////////////////////////////////////////////////////////////////////////////

Blocking APIS for IO : Blocking IO:
..................................

fs.readFileSync()
fs.writeFileSync()
//blocking IO
const fs = require('fs');
const path = require('path');

const options = {
    encoding: 'utf8'
}
const filePath = path.join(__dirname, 'assets/info.txt')
const writeFilePath = path.join(__dirname, 'assets/info_copy.txt')
console.log('start')
const data = fs.readFileSync(filePath, options);
console.log(data)
fs.writeFileSync(writeFilePath,'This is demo sync file io');

console.log('end');
////////////////////////////////////////////////////////////////////////////////////////

Evented IO : Streaming




































